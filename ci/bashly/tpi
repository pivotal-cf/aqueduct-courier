#!/usr/bin/env bash
# This script was generated by bashly 1.2.0 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
tpi_usage() {
  printf "tpi - App for provisioning and interacting with long-lived Shepherd environments, and storing the credentials in Vault.\n\n"

  printf "%s\n" "Usage:"
  printf "  tpi COMMAND\n"
  printf "  tpi [COMMAND] --help | -h\n"
  printf "  tpi --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List Shepherd environments owned my our team\n" "list    "
  printf "  %s   Create a long-lived environment using Shepherd\n" "create  "
  printf "  %s   Install the Telemetry Tile on the specified environment\n" "install "
  printf "  %s   Upload secrets to Vault\n" "update  "
  printf "  %s   Print telemetry_cli commands\n" "print   "
  printf "  %s   Get lockfile for foundation, write to local filesystem, and source for cf cli\n" "get     "
  printf "  %s   Open foundation\n" "open    "
  printf "  %s   The foundation that is currently targeted\n" "whoami  "
  printf "  %s   Ensure that all CI environments exist. Create any needed. Install the Telemetry Tile if needed. Upload secretes to Vault.\n" "maintain"
  printf "  %s   Open Ops Manager for a provided Shepherd lease\n" "lease   "
  printf "  %s   Given an Ops Manager version, get the corresponding Telemetry Tile version\n" "version "
  printf "  %s   Create TKGi test env\n" "tkgi    "
  printf "  %s   Renew the long-lived TAS environments\n" "renew   "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
tpi_list_usage() {
  printf "tpi list - List Shepherd environments owned my our team\n\n"

  printf "%s\n" "Usage:"
  printf "  tpi list [OPTIONS]\n"
  printf "  tpi list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--json"
    printf "    Return environments as JSON\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  tpi list\n"
    echo

  fi
}

# :command.usage
tpi_create_usage() {
  printf "tpi create - Create a long-lived environment using Shepherd\n\n"

  printf "%s\n" "Usage:"
  printf "  tpi create FOUNDATION\n"
  printf "  tpi create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "FOUNDATION"
    printf "    foundation to create\n"
    printf "    Allowed: production-jammy, acceptance-jammy, staging-jammy\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  tpi create acceptance-jammy\n"
    echo

  fi
}

# :command.usage
tpi_install_usage() {
  printf "tpi install - Install the Telemetry Tile on the specified environment\n\n"

  printf "%s\n" "Usage:"
  printf "  tpi install FOUNDATION\n"
  printf "  tpi install --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "FOUNDATION"
    printf "    foundation to install Telemetry Tile on\n"
    printf "    Allowed: production-jammy, acceptance-jammy\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  tpi install acceptance-jammy\n"
    echo

  fi
}

# :command.usage
tpi_update_usage() {
  printf "tpi update - Upload secrets to Vault\n\n"

  printf "%s\n" "Usage:"
  printf "  tpi update FOUNDATION\n"
  printf "  tpi update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "FOUNDATION"
    printf "    foundation to update Vault Secrets for\n"
    printf "    Allowed: production-jammy, acceptance-jammy, staging-jammy\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  tpi update acceptance-jammy\n"
    echo

  fi
}

# :command.usage
tpi_print_usage() {
  printf "tpi print - Print telemetry_cli commands\n\n"

  printf "%s\n" "Usage:"
  printf "  tpi print FOUNDATION [OPTIONS]\n"
  printf "  tpi print --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--collect"
    printf "    Return environments as JSON\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "FOUNDATION"
    printf "    foundation to print telemetry CLI commands of\n"
    printf "    Allowed: production-jammy, acceptance-jammy, staging-jammy, tas-6-test-env-1\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  tpi print acceptance-jammy\n"
    echo

  fi
}

# :command.usage
tpi_get_usage() {
  printf "tpi get - Get lockfile for foundation, write to local filesystem, and source for cf cli\n\n"

  printf "%s\n" "Usage:"
  printf "  tpi get FOUNDATION\n"
  printf "  tpi get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "FOUNDATION"
    printf "    foundation to get details for\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  tpi get acceptance-jammy\n"
    echo

  fi
}

# :command.usage
tpi_open_usage() {
  printf "tpi open - Open foundation\n\n"

  printf "%s\n" "Usage:"
  printf "  tpi open FOUNDATION\n"
  printf "  tpi open --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "FOUNDATION"
    printf "    foundation to open\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  tpi open acceptance-jammy\n"
    echo

  fi
}

# :command.usage
tpi_whoami_usage() {
  printf "tpi whoami - The foundation that is currently targeted\n\n"

  printf "%s\n" "Usage:"
  printf "  tpi whoami\n"
  printf "  tpi whoami --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  tpi whoami\n"
    echo

  fi
}

# :command.usage
tpi_maintain_usage() {
  printf "tpi maintain - Ensure that all CI environments exist. Create any needed. Install the Telemetry Tile if needed. Upload secretes to Vault.\n\n"

  printf "%s\n" "Usage:"
  printf "  tpi maintain\n"
  printf "  tpi maintain --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  tpi maintain\n"
    echo

  fi
}

# :command.usage
tpi_lease_usage() {
  printf "tpi lease - Open Ops Manager for a provided Shepherd lease\n\n"

  printf "%s\n" "Usage:"
  printf "  tpi lease ID\n"
  printf "  tpi lease --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    lease ID for a Shepherd environment\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  tpi lease 2910386c-37e0-40fa-9e76-b0927fc8364a\n"
    echo

  fi
}

# :command.usage
tpi_version_usage() {
  printf "tpi version - Given an Ops Manager version, get the corresponding Telemetry Tile version\n\n"

  printf "%s\n" "Usage:"
  printf "  tpi version TAG\n"
  printf "  tpi version --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TAG"
    printf "    Version of Ops Manager you would like to look up\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  tpi version v2.10.65\n"
    echo

  fi
}

# :command.usage
tpi_tkgi_usage() {
  printf "tpi tkgi - Create TKGi test env\n\n"

  printf "%s\n" "Usage:"
  printf "  tpi tkgi\n"
  printf "  tpi tkgi --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  tpi tkgi\n"
    echo

  fi
}

# :command.usage
tpi_renew_usage() {
  printf "tpi renew - Renew the long-lived TAS environments\n\n"

  printf "%s\n" "Usage:"
  printf "  tpi renew FOUNDATION\n"
  printf "  tpi renew --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "FOUNDATION"
    printf "    foundation to renew\n"
    printf "    Allowed: production-jammy, acceptance-jammy, staging-jammy\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  tpi renew acceptance-jammy\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg flags passthru
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/ensure_pivnet_login.sh
ensure_pivnet_login() {
	# Get Pivnet token
	export PIVNET_REFRESH_TOKEN=$(vault kv get -format=json /runway_concourse/tanzu-portfolio-insights/pivnet | jq -r '.data' | jq -r '.["refresh-token"]')

	# export PIVNET_ACCESS_TOKEN=$(curl -X POST https://network.tanzu.vmware.com/api/v2/authentication/access_tokens -d '{"refresh_token":$PIVNET_REFRESH_TOKEN}' | jq -r .access_token)
	# curl -X GET https://network.tanzu.vmware.com/api/v2/authentication -H "Authorization: Bearer $PIVNET_ACCESS_TOKEN"

	if ! pivnet login --api-token=$PIVNET_REFRESH_TOKEN &>/dev/null; then
		echo "Failed to login to pivnet" >&2
		exit 0
	fi
}

# src/lib/ensure_shepherd_login.sh
ensure_shepherd_login() {
	#export SHEPHERD_TOKEN=$(vault kv get -format=json /runway_concourse/tanzu-portfolio-insights/shepherd/tpi-telemetry | jq -r .data.secret)

	if ! $SHEPHERD_BINARY_PATH login user --json | jq -e '.login.User == "success"' &>/dev/null; then
		echo "Failed to login to shepherd" >&2
	fi
}

# src/lib/ensure_vault_login.sh
ensure_vault_login() {
	export VAULT_TOKEN=$(vault print token)

	if ! vault login "$VAULT_TOKEN" >/dev/null 2>&1; then
		echo "Enter your LDAP password:"
		if ! vault login -method=ldap 2>/dev/null; then
			echo "LDAP login failed. Please check your credentials or connection."
		fi
	fi
}

# src/lib/extract_env_details.sh
extract_env_details() {
	# SET ENV VARIABLES
	export TPI_ENV_TYPE=$(echo "$1" | cut -d '-' -f 1)
	export ENV_STEMCELL=$(echo "$1" | cut -d '-' -f 2)

	if [[ $(echo "$1" | cut -d '-' -f 3) == "test" ]]; then
		TPI_ENV_TYPE="development"
		ENV_STEMCELL="jammy"
	fi

	# GET ARRAY OF MATCHES ENVIRONMENTS
	env_array=$($SHEPHERD_BINARY_PATH list lease --namespace tpi-telemetry --desc-search "$1" --json)

	if [[ $(echo "$env_array" | jq '. | length') == 0 ]]; then
		echo -e "\nFoundation $1 does not exist\n"
		exit 1
	else
		# EXTRACT IDENTIFIER
		export ENV_IDENTIFIER=$(echo "$env_array" | jq -r '.[0].identifier')

		# GET LEASE
		echo -e "\nGetting $1 lease..."
		export ENV_LEASE=$($SHEPHERD_BINARY_PATH get lease "$ENV_IDENTIFIER" --namespace tpi-telemetry --json)

		# CHECK STATUS
		if [[ $(echo "$ENV_LEASE" | jq -r '.status') == "CREATING" ]]; then
			echo -e "\n*** Env still being created; try again later. ***\n"
			exit 1
		fi

		export LOCKFILE_DATA=$(echo "$ENV_LEASE" | jq -r .output)
	fi
}

# src/lib/set_shepherd_binary_path.sh
set_shepherd_binary_path() {
	local os=$(uname)
	local arch=$(uname -m)
	local binary_name=""

	case $os in
	Darwin)
		case $arch in
		x86_64) binary_name="shepherd-darwin-amd64" ;;
		arm64) binary_name="shepherd-darwin-arm64" ;;
		*)
			echo "Unsupported architecture: $arch"
			exit 1
			;;
		esac
		;;
	Linux)
		case $arch in
		x86_64) binary_name="shepherd-linux-amd64" ;;
		aarch64) binary_name="shepherd-linux-arm64" ;;
		*)
			echo "Unsupported architecture: $arch"
			exit 1
			;;
		esac
		;;
	*)
		echo "Unsupported operating system: $os"
		exit 1
		;;
	esac

	if [ -f "$PWD/src/binaries/$binary_name" ]; then
		chmod +x "$PWD/src/binaries/$binary_name"
		export SHEPHERD_BINARY_PATH="$PWD/src/binaries/$binary_name"
	else
		export SHEPHERD_BINARY_PATH=$(which shepherd)
	fi
}

# :command.command_functions
# :command.function
tpi_list_command() {
  # src/list_command.sh
  if [[ ${args[--json]:-0} == "1" ]]; then
  	$SHEPHERD_BINARY_PATH list lease --json --wide --namespace=tpi-telemetry
  else
  	$SHEPHERD_BINARY_PATH list lease --wide --namespace=tpi-telemetry
  fi

}

# :command.function
tpi_create_command() {
  # src/create_command.sh
  # Create correct environmnt if it doesn't already exist
  if [[ ${args[foundation]:-} == "" ]]; then
  	export ENV_DESCRIPTION=$1
  else
  	export ENV_DESCRIPTION=${args[foundation]}
  fi

  ENV_MATCHES=$($SHEPHERD_BINARY_PATH list lease --desc-search "$ENV_DESCRIPTION" --namespace tpi-telemetry --json)
  array_length=$(jq '. | length' <<<"$ENV_MATCHES")
  TELEMETRY_TILE_INSTALL_REQUIRED=false

  if [ "$array_length" -eq 0 ]; then
  	echo -e "$ENV_DESCRIPTION not found\n"

  	# Create TAS 5 if we need a jammy env
  	if [[ $ENV_DESCRIPTION == "production-jammy" || $ENV_DESCRIPTION == "acceptance-jammy" || $ENV_DESCRIPTION == "staging-jammy" ]]; then
  		echo -e "Creating $ENV_DESCRIPTION"

  		if [[ $ENV_DESCRIPTION == "production-jammy" || $ENV_DESCRIPTION == "acceptance-jammy" ]]; then
  			TELEMETRY_TILE_INSTALL_REQUIRED=true
  		fi

  		#$SHEPHERD_BINARY_PATH create lease --pool "tas-5_0" --duration 168h --namespace tpi-telemetry --description "$ENV_DESCRIPTION" --pool-namespace official
  		# Use Custom Env for up to date Ops Man (supporting Core Consumption API)

  		# FIXME: dynamically populate with latest Ops Man & TAS
  		# FIXME: specify up to date stemcell
  		# $SHEPHERD_BINARY_PATH create lease --template-namespace official --template-name gcp-tas-template --template-revision 2.1 --template-argument '{"configuration_folder": "3.0", "opsman_version": "3.0.30+LTS-T", "product_type": "srt*",  "tas_version": "6.0.4+LTS-T"}' --namespace tpi-telemetry --duration 168h --json --description "$ENV_DESCRIPTION"
  		$SHEPHERD_BINARY_PATH create lease --pool "tas-6_0" --duration 168h --namespace tpi-telemetry --description "$ENV_DESCRIPTION" --pool-namespace official

  		# Remove old metadata file
  		rm -rf "${PWD}/shepherd_envs/$ENV_DESCRIPTION-metadata.json"

  		# Remove old smith-data
  		rm -rf "${PWD}/smith-data/$ENV_DESCRIPTION"
  	fi

  	# # Create TAS 2.11 if we need a xenial env
  	# if [[ $ENV_DESCRIPTION == "production-xenial" || $ENV_DESCRIPTION == "acceptance-xenial" || $ENV_DESCRIPTION == "staging-xenial" ]]; then
  	# 	echo -e "Creating $ENV_DESCRIPTION"

  	# 	if [[ $ENV_DESCRIPTION == "production-xenial" || $ENV_DESCRIPTION == "acceptance-xenial" ]]; then
  	# 		TELEMETRY_TILE_INSTALL_REQUIRED=true
  	# 	fi

  	# 	#$SHEPHERD_BINARY_PATH create lease --pool "tas-2_11" --duration 168h --namespace tpi-telemetry --description "$ENV_DESCRIPTION" --pool-namespace official
  	# 	# Use Custom Env for up to date Ops Man (supporting Core Consumption API)

  	# 	# FIXME: dynamically populate with latest Ops Man & TAS
  	# 	# FIXME: specify up to date stemcell
  	# 	$SHEPHERD_BINARY_PATH create lease --template-namespace official --template-name gcp-tas-template --template-revision 2.1 --template-argument '{"configuration_folder": "2.7", "opsman_version": "2.10.73", "product_type": "srt*",  "tas_version": "2.11.57"}' --namespace tpi-telemetry --duration 168h --json --description "$ENV_DESCRIPTION"

  	# 	# Remove old metadata file
  	# 	rm -rf "${PWD}/shepherd_envs/$ENV_DESCRIPTION-metadata.json"

  	# 	# Remove old smith-data
  	# 	rm -rf "${PWD}/smith-data/$ENV_DESCRIPTION"
  	# fi

  	if [[ $TELEMETRY_TILE_INSTALL_REQUIRED == "true" ]]; then
  		echo -e "Install Telemetry Tile before updating Vault variables\n"
  	fi
  else
  	echo -e "$ENV_DESCRIPTION already exists"
  fi

}

# :command.function
tpi_install_command() {
  # src/install_command.sh
  #ensure_pivnet_login

  if [[ ${args[foundation]:-} == "" ]]; then
  	export TMP_FOUNDATION_NAME=$1
  else
  	export TMP_FOUNDATION_NAME=${args[foundation]}
  fi

  tpi_get_command $TMP_FOUNDATION_NAME

  LOCKFILE_PATH="${PWD}/shepherd_envs/$TMP_FOUNDATION_NAME-metadata.json"

  # Check that this foundation doesn't already have the Telemetry Tile installed
  export TELEMETRY_TILE_GUID=$(smith om --lockfile="${PWD}/shepherd_envs/$TMP_FOUNDATION_NAME-metadata.json" -- curl -s --path /api/v0/deployed/products | jq -r '.[] | select(.type == "pivotal-telemetry-om").guid') || ""
  if [[ -n $TELEMETRY_TILE_GUID ]]; then
  	echo -e "\nThe Telemetry Tile is already installed\n"
  	return 0
  fi

  # FIXME: target system org / space (create if necessary)
  smith cf-login --lockfile="$LOCKFILE_PATH"

  # FIXME: these don't work sometimes
  # do we need to eval the bosh vars twice??
  # do source instead
  # make sure the empty export= env var isn't set
  # set output of om bosh-env ??
  eval $(smith om -l "$LOCKFILE_PATH")
  eval $(smith bosh -l "$LOCKFILE_PATH")

  # Enable the Usage Service Errand
  export TAS_TILE_GUID=$(om curl --silent --path /api/v0/deployed/products | jq -r '.[] | select(.type == "cf").guid')
  om curl --silent --path "/api/v0/staged/products/$TAS_TILE_GUID/errands" -x PUT -d '{"errands":[{"name":"push-usage-service","post_deploy":true}]}'

  # errand_exists=$(bosh errands --json | jq -r '.["Tables"]' | jq -r '.[0]' | jq -r '.["Rows"]' | jq 'any(.[]; .name == "push-usage-service")')
  # CF_DEPLOYMENT="$(bosh deployments --json | jq -r '.Tables[] | select(.Content="deployments") | .Rows[] | select(.name | test("^cf-")) | .name')"
  # bosh run-errand -d "$CF_DEPLOYMENT" push-usage-service

  # Get details of latest Telemetry Tile
  # PRODUCT_NAME="pivotal-telemetry-om"
  # TILE_INFO_JSON=$(pivnet releases --format=json -p "$PRODUCT_NAME" -l 1)
  # TILE_VERSION=$(echo $TILE_INFO_JSON | jq -r '.[0].version')

  # FIXME: this doesn't work for Xenial environments until
  # they switch to bundling our 1.3.x line by default. For
  # now, manually upload the 1.3.x tile and re-run this command.
  TILE_FULL_VERSION=$(om products --format=json | jq '.[] | select(.name == "pivotal-telemetry-om")' | jq -r .available | jq -r '.[0]')

  # Download latest Telemetry Tile
  # rm -rf /tmp/tile
  # mkdir /tmp/tile
  # pivnet download-product-files --accept-eula --download-dir=/tmp/tile -p "$PRODUCT_NAME" -r "$TILE_VERSION" -g "*.pivotal"

  network="$(smith read --lockfile=$LOCKFILE_PATH | jq -r .ert_subnet)"
  az="us-central1-f"

  function retry {
  	local retries=$1
  	local count=0
  	shift

  	until "$@"; do
  		exit=$?
  		count=$((count + 1))
  		if [ $count -lt $retries ]; then
  			echo "Attempt $count/$retries ended with exit $exit"
  			# Need a short pause between smith CLI executions or it fails unexpectedly.
  			sleep 30
  		else
  			echo "Attempted $count/$retries times and failed."
  			return $exit
  		fi
  	done
  	return 0
  }

  export LOADER_API_KEY=$(vault kv get -format=json /runway_concourse/tanzu-portfolio-insights/aqueduct-loader | jq -r '.data' | jq -r '.["production-loader-api-keys"]' | jq -r '.["Telemetry and Insights"]' | jq -r '.[0]')
  echo -e "Loader API Key:\t$LOADER_API_KEY"

  # echo "Uploading tile..."
  # retry 5 smith om --lockfile=$LOCKFILE_PATH -- upload-product --product "/tmp/tile/pivotal-telemetry-om-$TILE_VERSION.pivotal"

  echo "Staging tile..."
  retry 5 om stage-product \
  	--product-name "pivotal-telemetry-om" \
  	--product-version "$TILE_FULL_VERSION"

  FOUNDATION_NICKNAME=$(cat $LOCKFILE_PATH | jq .name)
  TILE_ENV_TYPE=$TPI_ENV_TYPE
  if [[ $TPI_ENV_TYPE == "acceptance" ]]; then
  	TILE_ENV_TYPE="qa"
  	FOUNDATION_NICKNAME="best-acceptance-env"
  fi

  echo "Configuring tile..."
  retry 5 om configure-product \
  	--config "$HOME/workspace/tile/p-telemetry/ci/tasks/product-config.yml" \
  	--var audit-mode="false" \
  	--var env-type="$TILE_ENV_TYPE" \
  	--var foundation-nickname="$FOUNDATION_NICKNAME" \
  	--var loader-endpoint="https://telemetry.pivotal.io" \
  	--var telemetry-api-key="$LOADER_API_KEY" \
  	--var flush-interval=10 \
  	--var collector-cron-schedule="0 8 * * *" \
  	--var network="$network" \
  	--var az="$az" \
  	--var ops-manager-timeout=30 \
  	--var ops-manager-request-timeout=15

  # echo "Uploading stemcell..."
  # retry 5 smith om -- upload-stemcell --stemcell stemcell/*.tgz

  # echo "Assigning stemcell to tile..."
  # retry 5 smith om -- assign-stemcell \
  #    --product pivotal-telemetry-om

  smith open --lockfile="$LOCKFILE_PATH"

  echo "Applying changes..."
  rm -rf /tmp/bashly/logs
  mkdir -p /tmp/bashly/logs
  LOG_FILE=/tmp/bashly/logs/$TMP_FOUNDATION_NAME.log
  touch $LOG_FILE
  nohup om apply-changes --reattach >$LOG_FILE 2>&1 &

  echo -e "Run the following command to watch the install:\n"
  echo -e "tail -f ${LOG_FILE}"

}

# :command.function
tpi_update_command() {
  # src/update_command.sh
  if [[ ${args[foundation]:-} == "" ]]; then
  	export TMP_FOUNDATION_NAME=$1
  else
  	export TMP_FOUNDATION_NAME=${args[foundation]}
  fi

  tpi_get_command $TMP_FOUNDATION_NAME

  update_vault() {
  	ENV_DESCRIPTION=$TMP_FOUNDATION_NAME

  	# Write the lockfile to a secret
  	vault kv put runway_concourse/tanzu-portfolio-insights/toolsmiths/"${ENV_DESCRIPTION}"-lockfile @"${PWD}/shepherd_envs/$ENV_DESCRIPTION-metadata.json"

  	# Do the updating
  	if [[ $TPI_ENV_TYPE == "staging" || $(echo $TPI_ENV_TYPE | grep -q 'p-telemetry') || $(echo $TPI_ENV_TYPE | grep -q 'telemetry-release') ]]; then
  		vault kv put runway_concourse/tanzu-portfolio-insights/toolsmiths/"${ENV_DESCRIPTION}" \
  			env-name="${NAME}" \
  			p-bosh-id-guid="${P_BOSH_ID}"
  		echo -e "\nUpdated 2 Vault variables for ${ENV_DESCRIPTION}\n"
  	else
  		vault kv put runway_concourse/tanzu-portfolio-insights/toolsmiths/"${ENV_DESCRIPTION}" \
  			cf-api-url="https://api.${SYS_DOMAIN}" \
  			env-name="${NAME}" \
  			gcp-project-id="${GCP_PROJECT_ID}" \
  			gcp-zone="us-central1-f" \
  			iaas_type="google" \
  			ops-manager-hostname="${OPS_MANAGER_DNS}" \
  			ops-manager-url="${OPS_MANAGER_URL}" \
  			opsman-client-id="restricted_view_api_access" \
  			opsman-instance-name="${NAME}-ops-manager" \
  			opsman-password="${OPS_MANAGER_PASSWORD}" \
  			opsman-uaa-client-secret="${UAA_CLIENT_SECRET}" \
  			opsman-username="${OPS_MANAGER_USERNAME}" \
  			p-bosh-id-guid="${P_BOSH_ID}" \
  			telemetry-tile-guid="${TELEMETRY_TILE_GUID}" \
  			telemetry-usage-service-password="${TELEMETRY_USAGE_SERVICE_PASSWORD}" \
  			usage-service-client-id="usage_service" \
  			usage-service-url="https://app-usage.${SYS_DOMAIN}"

  		echo -e "\nUpdated 17 Vault variables for ${ENV_DESCRIPTION}\n"
  	fi
  }

  echo -e "ALL_ENVS_READY: $ALL_ENVS_READY"
  if [ "$ALL_ENVS_READY" = true ]; then
  	update_vault
  else
  	echo -e "The following environments are not ready:"
  	for not_ready_env in "${NOT_READY_ENVS[@]}"; do
  		echo -e "$not_ready_env"
  	done
  fi

}

# :command.function
tpi_print_command() {
  # src/print_command.sh
  if [[ ${args[foundation]} == "" ]]; then
  	export TMP_FOUNDATION_NAME=$1
  else
  	export TMP_FOUNDATION_NAME=${args[foundation]}
  fi

  tpi_get_command $TMP_FOUNDATION_NAME
  ENV_DESCRIPTION=$TMP_FOUNDATION_NAME

  echo -e "\n\n********** CLI COMMANDS: USERNAME / PASSWORD **********"

  # CLI STRINGS
  echo -e "\n** CEIP ONLY **"
  mkdir -p "${PWD}/smith-data/$ENV_DESCRIPTION/username-password/ceip"
  echo "telemetry-collector collect \\
      --insecure-skip-tls-verify \\
      --url ${OPS_MANAGER_URL} \\
      --username pivotalcf \\
      --password ${OPS_MANAGER_PASSWORD} \\
      --env-type development \\
      --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/username-password/ceip"

  if [[ ${args[--collect]:-} ]]; then
  	eval "telemetry-collector collect \\
          --insecure-skip-tls-verify \\
          --url ${OPS_MANAGER_URL} \\
          --username pivotalcf \\
          --password ${OPS_MANAGER_PASSWORD} \\
          --env-type development \\
          --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/username-password/ceip"
  fi

  if [ -n "$TELEMETRY_USAGE_SERVICE_PASSWORD" ]; then
  	echo -e "\n\n** OPERATIONAL DATA ONLY - WITH USAGE **"
  	mkdir -p "${PWD}/smith-data/$ENV_DESCRIPTION/username-password/operational-data-only-with-usage"
  	echo -e "telemetry-collector collect \\
          --insecure-skip-tls-verify \\
          --url ${OPS_MANAGER_URL} \\
          --username pivotalcf \\
          --password ${OPS_MANAGER_PASSWORD} \\
          --usage-service-url https://app-usage.${SYS_DOMAIN} \\
          --usage-service-client-id usage_service \\
          --usage-service-client-secret ${TELEMETRY_USAGE_SERVICE_PASSWORD} \\
          --cf-api-url https://api.${SYS_DOMAIN} \\
          --usage-service-insecure-skip-tls-verify \\
          --env-type development \\
          --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/username-password/operational-data-only-with-usage \\
          --operational-data-only"

  	if [[ ${args[--collect]:-} ]]; then
  		eval "telemetry-collector collect \\
              --insecure-skip-tls-verify \\
              --url ${OPS_MANAGER_URL} \\
              --username pivotalcf \\
              --password ${OPS_MANAGER_PASSWORD} \\
              --usage-service-url https://app-usage.${SYS_DOMAIN} \\
              --usage-service-client-id usage_service \\
              --usage-service-client-secret ${TELEMETRY_USAGE_SERVICE_PASSWORD} \\
              --cf-api-url https://api.${SYS_DOMAIN} \\
              --usage-service-insecure-skip-tls-verify \\
              --env-type development \\
              --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/username-password/operational-data-only-with-usage \\
              --operational-data-only"
  	fi
  fi

  echo -e "\n\n** OPERATIONAL DATA ONLY - NO USAGE **"
  mkdir -p "${PWD}/smith-data/$ENV_DESCRIPTION/username-password/operational-data-only-no-usage"
  echo "telemetry-collector collect \\
      --url ${OPS_MANAGER_URL} \\
      --insecure-skip-tls-verify \\
      --username pivotalcf \\
      --password ${OPS_MANAGER_PASSWORD} \\
      --env-type development \\
      --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/username-password/operational-data-only-no-usage \\
      --operational-data-only"

  if [[ ${args[--collect]:-} ]]; then
  	eval "telemetry-collector collect \\
          --url ${OPS_MANAGER_URL} \\
          --insecure-skip-tls-verify \\
          --username pivotalcf \\
          --password ${OPS_MANAGER_PASSWORD} \\
          --env-type development \\
          --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/username-password/operational-data-only-no-usage \\
          --operational-data-only"
  fi

  if [ -n "$TELEMETRY_USAGE_SERVICE_PASSWORD" ]; then
  	echo -e "\n\n** ALL **"
  	mkdir -p "${PWD}/smith-data/$ENV_DESCRIPTION/username-password/all"
  	echo "telemetry-collector collect \\
          --insecure-skip-tls-verify \\
          --url ${OPS_MANAGER_URL} \\
          --username pivotalcf \\
          --password ${OPS_MANAGER_PASSWORD} \\
          --usage-service-url https://app-usage.${SYS_DOMAIN} \\
          --usage-service-client-id usage_service \\
          --usage-service-client-secret ${TELEMETRY_USAGE_SERVICE_PASSWORD} \\
          --cf-api-url https://api.${SYS_DOMAIN} \\
          --usage-service-insecure-skip-tls-verify \\
          --env-type development \\
          --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/username-password/all"

  	if [[ ${args[--collect]:-} ]]; then
  		eval "telemetry-collector collect \\
              --insecure-skip-tls-verify \\
              --url ${OPS_MANAGER_URL} \\
              --username pivotalcf \\
              --password ${OPS_MANAGER_PASSWORD} \\
              --usage-service-url https://app-usage.${SYS_DOMAIN} \\
              --usage-service-client-id usage_service \\
              --usage-service-client-secret ${TELEMETRY_USAGE_SERVICE_PASSWORD} \\
              --cf-api-url https://api.${SYS_DOMAIN} \\
              --usage-service-insecure-skip-tls-verify \\
              --env-type development \\
              --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/username-password/all"
  	fi
  fi

  if [ -n "$TELEMETRY_USAGE_SERVICE_PASSWORD" ]; then
  	echo -e "\n\n********** CLI COMMANDS: CLIENT ID / CLIENT SECRET **********"
  	# CLIENT ID / CLIENT SECRET

  	echo -e "\n** CEIP ONLY **"
  	mkdir -p "${PWD}/smith-data/$ENV_DESCRIPTION/client-id-client-secret/ceip"
  	echo "telemetry-collector collect \\
          --insecure-skip-tls-verify \\
          --url ${OPS_MANAGER_URL} \\
          --client-id restricted_view_api_access \\
          --client-secret ${UAA_CLIENT_SECRET} \\
          --env-type development \\
          --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/client-id-client-secret/ceip"

  	if [[ ${args[--collect]:-} ]]; then
  		eval "telemetry-collector collect \\
              --insecure-skip-tls-verify \\
              --url ${OPS_MANAGER_URL} \\
              --client-id restricted_view_api_access \\
              --client-secret ${UAA_CLIENT_SECRET} \\
              --env-type development \\
              --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/client-id-client-secret/ceip"
  	fi

  	if [ -n "$TELEMETRY_USAGE_SERVICE_PASSWORD" ]; then
  		echo -e "\n\n** OPERATIONAL DATA ONLY - WITH USAGE **"
  		mkdir -p "${PWD}/smith-data/$ENV_DESCRIPTION/client-id-client-secret/operational-data-only-with-usage"
  		echo -e "telemetry-collector collect \\
              --insecure-skip-tls-verify \\
              --url ${OPS_MANAGER_URL} \\
              --client-id restricted_view_api_access \\
              --client-secret ${UAA_CLIENT_SECRET} \\
              --usage-service-url https://app-usage.${SYS_DOMAIN} \\
              --usage-service-client-id usage_service \\
              --usage-service-client-secret ${TELEMETRY_USAGE_SERVICE_PASSWORD} \\
              --cf-api-url https://api.${SYS_DOMAIN} \\
              --usage-service-insecure-skip-tls-verify \\
              --env-type development \\
              --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/client-id-client-secret/operational-data-only-with-usage \\
              --operational-data-only"

  		if [[ ${args[--collect]:-} ]]; then
  			eval "telemetry-collector collect \\
                  --insecure-skip-tls-verify \\
                  --url ${OPS_MANAGER_URL} \\
                  --client-id restricted_view_api_access \\
                  --client-secret ${UAA_CLIENT_SECRET} \\
                  --usage-service-url https://app-usage.${SYS_DOMAIN} \\
                  --usage-service-client-id usage_service \\
                  --usage-service-client-secret ${TELEMETRY_USAGE_SERVICE_PASSWORD} \\
                  --cf-api-url https://api.${SYS_DOMAIN} \\
                  --usage-service-insecure-skip-tls-verify \\
                  --env-type development \\
                  --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/client-id-client-secret/operational-data-only-with-usage \\
                  --operational-data-only"
  		fi
  	fi

  	echo -e "\n\n** OPERATIONAL DATA ONLY - NO USAGE **"
  	mkdir -p "${PWD}/smith-data/$ENV_DESCRIPTION/client-id-client-secret/operational-data-only-no-usage"
  	echo "telemetry-collector collect \\
          --insecure-skip-tls-verify \\
          --url ${OPS_MANAGER_URL} \\
          --client-id restricted_view_api_access \\
          --client-secret ${UAA_CLIENT_SECRET} \\
          --env-type development \\
          --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/client-id-client-secret/operational-data-only-no-usage \\
          --operational-data-only"

  	if [[ ${args[--collect]:-} ]]; then
  		eval "telemetry-collector collect \\
              --insecure-skip-tls-verify \\
              --url ${OPS_MANAGER_URL} \\
              --client-id restricted_view_api_access \\
              --client-secret ${UAA_CLIENT_SECRET} \\
              --env-type development \\
              --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/client-id-client-secret/operational-data-only-no-usage \\
              --operational-data-only"
  	fi

  	if [ -n "$TELEMETRY_USAGE_SERVICE_PASSWORD" ]; then
  		echo -e "\n\n** ALL **"
  		mkdir -p "${PWD}/smith-data/$ENV_DESCRIPTION/client-id-client-secret/all"
  		echo -e "telemetry-collector collect \\
              --insecure-skip-tls-verify \\
              --url ${OPS_MANAGER_URL} \\
              --client-id restricted_view_api_access \\
              --client-secret ${UAA_CLIENT_SECRET} \\
              --usage-service-url https://app-usage.${SYS_DOMAIN} \\
              --usage-service-client-id usage_service \\
              --usage-service-client-secret ${TELEMETRY_USAGE_SERVICE_PASSWORD} \\
              --cf-api-url https://api.${SYS_DOMAIN} \\
              --usage-service-insecure-skip-tls-verify \\
              --env-type development \\
              --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/client-id-client-secret/all"

  		if [[ ${args[--collect]:-} ]]; then
  			eval "telemetry-collector collect \\
                  --insecure-skip-tls-verify \\
                  --url ${OPS_MANAGER_URL} \\
                  --client-id restricted_view_api_access \\
                  --client-secret ${UAA_CLIENT_SECRET} \\
                  --usage-service-url https://app-usage.${SYS_DOMAIN} \\
                  --usage-service-client-id usage_service \\
                  --usage-service-client-secret ${TELEMETRY_USAGE_SERVICE_PASSWORD} \\
                  --cf-api-url https://api.${SYS_DOMAIN} \\
                  --usage-service-insecure-skip-tls-verify \\
                  --env-type development \\
                  --output-dir ${PWD}/smith-data/${ENV_DESCRIPTION}/client-id-client-secret/all"
  		fi
  	fi
  fi

}

# :command.function
tpi_get_command() {
  # src/get_command.sh
  if [[ ${args[foundation]:-} == "" ]]; then
  	export TMP_FOUNDATION_NAME=$1
  else
  	export TMP_FOUNDATION_NAME=${args[foundation]}
  fi

  extract_env_details $TMP_FOUNDATION_NAME

  mkdir -p "${PWD}/shepherd_envs"
  export LOCKFILE_PATH=${PWD}/shepherd_envs/$TMP_FOUNDATION_NAME-metadata.json

  if [[ $LOCKFILE_DATA == null ]]; then
  	echo -e "\n*** Env not yet ready; try again later. ***\n"
  	exit 0
  else
  	echo "$LOCKFILE_DATA" >"$LOCKFILE_PATH"
  fi

  if [ ! -f $LOCKFILE_PATH ]; then
  	echo -e "$TMP_FOUNDATION_NAME:\tCannot find lockfile"
  	exit 0
  fi

  # Source envs for smith, cf, bosh CLIs
  echo -e "Targeting $TMP_FOUNDATION_NAME..."
  smith cf-login --lockfile="$LOCKFILE_PATH"

  smith om -l "$LOCKFILE_PATH" >/tmp/bashly_om_env.sh
  source /tmp/bashly_om_env.sh

  smith bosh -l "$LOCKFILE_PATH" >/tmp/bashly_bosh_env.sh
  source /tmp/bashly_bosh_env.sh

  export SYS_DOMAIN=$(cf api | grep 'API endpoint' | awk '{print $3}' | cut -d'/' -f3 | sed 's/^api\.//') || ""

  echo -e "\nGetting env variables...\n"

  # Function to get ops_manager password
  fetch_ops_manager_pw() {
  	export OPS_MANAGER_PASSWORD=$(smith read --lockfile="$LOCKFILE_PATH" | jq -r .ops_manager.password)
  	echo -e "OPS_MANAGER_PASSWORD:\t\t\t$OPS_MANAGER_PASSWORD"
  }

  # Function to get ops_manager username
  fetch_ops_manager_username() {
  	export OPS_MANAGER_USERNAME=$(smith read --lockfile="$LOCKFILE_PATH" | jq -r .ops_manager.username)
  	echo -e "OPS_MANAGER_USERNAME:\t\t\t$OPS_MANAGER_USERNAME"
  }

  # Function to get ops_manager url
  fetch_ops_manager_url() {
  	export OPS_MANAGER_URL=$(smith read --lockfile="$LOCKFILE_PATH" | jq -r .ops_manager.url)
  	echo -e "OPS_MANAGER_URL:\t\t\t$OPS_MANAGER_URL"
  }

  # Function to get ops_manager dns
  fetch_ops_manager_dns() {
  	export OPS_MANAGER_DNS=$(smith read --lockfile="$LOCKFILE_PATH" | jq -r .ops_manager_dns)
  	echo -e "OPS_MANAGER_DNS:\t\t\t$OPS_MANAGER_DNS"
  }

  # Function to get p_bosh_id
  fetch_p_bosh_id() {
  	export P_BOSH_ID=$(smith om --lockfile="$LOCKFILE_PATH" -- curl -s --path=/api/v0/deployed/products | jq -r ".[].guid" | grep bosh)
  	echo -e "P_BOSH_ID:\t\t\t\t$P_BOSH_ID"
  }

  # Function to get cf_guid
  fetch_cf_guid() {
  	export CF_GUID=$(smith om --lockfile="$LOCKFILE_PATH" -- curl -s --path /api/v0/deployed/products | jq -r '.[] | select(.type == "cf").guid')
  	if [ -n "$CF_GUID" ]; then
  		echo -e "CF_GUID:\t\t\t\t$CF_GUID"
  	else
  		echo -e "CF_GUID:"
  	fi
  }

  # Function to get GPC project id
  fetch_gcp_project_id() {
  	#GCP_PROJECT_ID=$(smith om --lockfile=$LOCKFILE_PATH -- curl -s --path /api/v0/staged/director/iaas_configurations | jq -r '.iaas_configurations[0].project')
  	export GCP_PROJECT_ID=$(smith read --lockfile="$LOCKFILE_PATH" | jq -r .project)
  	echo -e "GCP_PROJECT_ID:\t\t\t\t$GCP_PROJECT_ID"
  }

  # Function to get name
  fetch_name() {
  	export NAME=$(smith read --lockfile="$LOCKFILE_PATH" | jq -r .name)
  	echo -e "NAME:\t\t\t\t\t$NAME"
  }

  export FOUNDATION=$TMP_FOUNDATION_NAME


  # Function to get Telemetry Tile guid
  fetch_telemetry_tile_guid() {
  	if [[ $TPI_ENV_TYPE != "staging" ]]; then
  		export TELEMETRY_TILE_GUID=$(smith om --lockfile="$LOCKFILE_PATH" -- curl -s --path /api/v0/deployed/products | jq -r '.[] | select(.type == "pivotal-telemetry-om").guid') || ""
  		echo -e "TELEMETRY_TILE_GUID:\t\t\t$TELEMETRY_TILE_GUID"
  	fi
  }

  # Function to get uaa_client_secret
  fetch_uaa_client_secret() {
  	if [[ $TPI_ENV_TYPE != "staging" ]]; then

  		if [[ -z $TELEMETRY_TILE_GUID ]]; then
  			echo -e "*** No TELEMETRY_TILE_GUID ***"
  			echo -e "UAA_CLIENT_SECRET:"
  		else
  			export UAA_CLIENT_SECRET=$(smith om --lockfile="$LOCKFILE_PATH" -- curl -s --path /api/v0/deployed/products/"${TELEMETRY_TILE_GUID}"/manifest | jq -r '.instance_groups[] | select(.name == "telemetry-centralizer").jobs[] | select(.name == "telemetry-collector").properties.opsmanager.auth.uaa_client_secret') 2>/dev/null || ""

  			if [ -z "${UAA_CLIENT_SECRET}" ]; then
  				echo -e "*** ENVIRONMENT NOT READY ***"
  				export ALL_ENVS_READY=false
  				NOT_READY_ENVS+=($TMP_FOUNDATION_NAME)
  			fi

  			echo -e "UAA_CLIENT_SECRET:\t\t\t$UAA_CLIENT_SECRET"
  		fi
  	fi
  }

  # Function to make an API call using the cf_guid and print the telemetry_usage_service_password
  fetch_telemetry_usage_service_password() {
  	export TELEMETRY_USAGE_SERVICE_PASSWORD=""

  	if [[ $TPI_ENV_TYPE != "staging" ]]; then
  		if [ -n "$CF_GUID" ]; then
  			TELEMETRY_USAGE_SERVICE_PASSWORD=$(smith om --lockfile="$LOCKFILE_PATH" -- curl -s --path /api/v0/deployed/products/"${CF_GUID}"/credentials/.uaa.usage_service_client_credentials | jq -r .credential.value.password)
  			echo -e "TELEMETRY_USAGE_SERVICE_PASSWORD:\t$TELEMETRY_USAGE_SERVICE_PASSWORD"
  		else
  			echo -e "TELEMETRY_USAGE_SERVICE_PASSWORD:"
  		fi
  	fi
  }

  fetch_ops_manager_pw
  fetch_ops_manager_username
  fetch_ops_manager_url
  fetch_ops_manager_dns
  fetch_p_bosh_id
  fetch_gcp_project_id
  fetch_name
  fetch_cf_guid

  fetch_telemetry_tile_guid
  fetch_uaa_client_secret
  fetch_telemetry_usage_service_password

  if [[ $TPI_ENV_TYPE != "staging" ]]; then
  	if [[ -z $TELEMETRY_TILE_GUID ]]; then
  		echo -e "\n*** YOU MUST INSTALL THE TELEMETRY TILE ***\n"
  	fi
  fi

}

# :command.function
tpi_open_command() {
  # src/open_command.sh
  # Set foundation based on command line arg or passed in name
  if [[ ${args[foundation]} == "" ]]; then
  	export TMP_FOUNDATION_NAME=$1
  else
  	export TMP_FOUNDATION_NAME=${args[foundation]}
  fi

  # Set lockfile path
  LOCKFILE_PATH="${PWD}/shepherd_envs/$TMP_FOUNDATION_NAME-metadata.json"

  if [ -f "$LOCKFILE_PATH" ]; then
  	smith open --lockfile="${PWD}/shepherd_envs/$TMP_FOUNDATION_NAME-metadata.json"
  else
  	echo -e "No lockfile found for $TMP_FOUNDATION_NAME"
  fi

}

# :command.function
tpi_whoami_command() {
  # src/whoami_command.sh
  # FIXME: only works for environments with TAS, won't detect if environment has been reaped
  export SYS_DOMAIN=$(cf api | grep 'API endpoint' | awk '{print $3}' | cut -d'/' -f3 | sed 's/^api\.//') || ""

  if [[ -z $SYS_DOMAIN ]]; then
  	echo -e "No foundations targeted"
  	exit 0
  fi

  if [ $(cat shepherd_envs/acceptance-jammy-metadata.json | jq -r .sys_domain) = $SYS_DOMAIN ]; then
  	echo -e "acceptance-jammy"
  	exit 0
  fi

  if [ $(cat shepherd_envs/production-jammy-metadata.json | jq -r .sys_domain) = $SYS_DOMAIN ]; then
  	echo -e "production-jammy"
  	exit 0
  fi

  if [ $(cat shepherd_envs/staging-jammy-metadata.json | jq -r .sys_domain) = $SYS_DOMAIN ]; then
  	echo -e "staging-jammy"
  	exit 0
  fi

  echo -e "Targeted foundation does not match a Shepherd Env"

}

# :command.function
tpi_maintain_command() {
  # src/maintain_command.sh
  export ALL_ENVS_READY=true
  export NOT_READY_ENVS=()
  export ENVS_JSON=$(tpi_list_command --json)
  export CI_ENVS=(production-jammy acceptance-jammy staging-jammy)
  mkdir -p "${PWD}/shepherd_envs"

  # The idea of this command is that it can be run continuously
  # and it will maintain the necessary long-lived environments
  # as well as installing the Telemetry Tile and uploading the
  # secrets to Vault.

  # TODO: have script run every 6 hours

  # Function that takes in a string and returns a boolean.
  # Checks to see if if there is a JSON object within ENVS_JSON
  # where the value of the "description" key is set to the value of
  # the string we're processing from CI_ENVS
  # FIXME: function is currently un-used
  env_exists() {
  	if $SHEPHERD_BINARY_PATH list lease --json --wide --namespace=tpi-telemetry | jq -r --arg env "$1" 'any(.[]; .description == $env)' | grep -q true; then
  		return 0
  	else
  		printf "%s\n" "$1"
  		return 1
  	fi

  }

  # Function that takes in a string and returns a boolean.
  # Checks to see if environment is ready by checking for
  # existance of lockfile.
  env_ready() {
  	if [[ $LOCKFILE_DATA == null ]]; then
  		return 1
  	else
  		return 0
  	fi
  }

  # Function to get Telemetry Tile guid
  telemetry_installed() {
  	export TELEMETRY_TILE_GUID=""
  	if [ -f "$LOCKFILE_PATH" ]; then
  		export TELEMETRY_TILE_GUID=$(smith om --lockfile="$LOCKFILE_PATH" -- curl -s --path /api/v0/deployed/products | jq -r '.[] | select(.type == "pivotal-telemetry-om").guid') || ""
  		if [[ -z $TELEMETRY_TILE_GUID ]]; then
  			return 1
  		else
  			return 0
  		fi
  	else
  		return 1
  	fi
  }

  check_all_envs_exist() {
  	echo -e "Checking that all enivronments exist..."
  	for my_env in "${CI_ENVS[@]}"; do
  		# If env already exists, this is a no-op
  		tpi_create_command "$my_env"
  	done

  	echo "*** All environments exist. ***"
  }

  # Will exit as soon as it finds an
  # enviroment that isn't ready
  # FIXME: function currently un-used
  check_all_envs_ready() {
  	echo -e "Checking that all enivronments are ready..."
  	for my_env in "${CI_ENVS[@]}"; do
  		tpi_get_command "$my_env"
  		export LOCKFILE_PATH=${PWD}/shepherd_envs/$my_env-metadata.json
  		export TPI_ENV_TYPE=$(echo "$my_env" | cut -d '-' -f 1)
  		if ! env_ready; then
  			printf "%s not ready. Please wait.\n" "$my_env"
  			exit 0
  		fi
  	done

  	echo "*** All environments ready. ***"
  }

  # Will exit as soon as it finds an
  # environment that needs the Telemety
  # Tile but doesn't have it installed.
  # Will kick off installation of Tile.
  check_telemetry_tile_installed() {
  	for my_env in "${CI_ENVS[@]}"; do
  		extract_env_details "$my_env"
  		export LOCKFILE_PATH=${PWD}/shepherd_envs/$my_env-metadata.json
  		export TPI_ENV_TYPE=$(echo "$my_env" | cut -d '-' -f 1)
  		if [[ $TPI_ENV_TYPE != "staging" ]]; then
  			if ! telemetry_installed; then
  				tpi_install_command "$my_env"
  				# TODO: can this be removed (will we have the Vault secrets??)
  				# exit 0
  			else
  				printf "\nTelemetry Tile is installed on $my_env"
  			fi
  		else
  			printf "\nStaging Env: Telemetry Tile not necessary...\n"
  		fi
  	done

  	echo -e "*** All (necessary) Telemetry Tiles installed. ***"
  }

  # Note: will continue to upload secrets even if they already exist
  upload_secrets_to_vault() {
  	echo -e "Uploading secrets to Vault..."
  	for my_env in "${CI_ENVS[@]}"; do
  		extract_env_details "$my_env"
  		export LOCKFILE_PATH=${PWD}/shepherd_envs/$my_env-metadata.json
  		export TPI_ENV_TYPE=$(echo "$my_env" | cut -d '-' -f 1)

  		tpi_update_command "$my_env"
  	done

  	echo "*** Secrets uploaded to Vault. ***"
  }

  check_all_envs_exist
  check_telemetry_tile_installed

  # Let the Telemetry Tile install
  sleep 5
  echo -e "Waiting for background jobs to finish..."
  wait $(jobs -p)
  echo -e "Background jobs complete."

  echo -e "ALL_ENVS_READY: $ALL_ENVS_READY"
  if [ "$ALL_ENVS_READY" = true ]; then
  	echo -e "*** ALL ENVS READY ***"
  	upload_secrets_to_vault
  else
  	echo -e "The following environments are not ready:"
  	for not_ready_env in "${NOT_READY_ENVS[@]}"; do
  		echo -e "$not_ready_env"
  	done
  fi

  # TODO: Set environment expiration to coincide with opsman_tls_certificate expiration
  renew_long_lived_envs() {
  	echo -e "Renewing long-lived envs..."
  	for my_env in "${CI_ENVS[@]}"; do
  		extract_env_details "$my_env"
  		export LOCKFILE_PATH=${PWD}/shepherd_envs/$my_env-metadata.json
  		export TPI_ENV_TYPE=$(echo "$my_env" | cut -d '-' -f 1)

  		tpi_renew_command "$my_env"
  	done

  	echo "*** Long-lived envs renewed. ***"
  }

  renew_long_lived_envs

}

# :command.function
tpi_lease_command() {
  # src/lease_command.sh
  ENV_IDENTIFIER=${args[id]}

  export ENV_LEASE=$($SHEPHERD_BINARY_PATH get lease "$ENV_IDENTIFIER" --namespace tpi-telemetry --json)
  export LOCKFILE_DATA=$(echo "$ENV_LEASE" | jq -r .output)

  echo "$LOCKFILE_DATA" >/tmp/lease.json
  export LOCKFILE_PATH=/tmp/lease.json

  smith cf-login --lockfile=$LOCKFILE_PATH
  cf create-space system
  cf target -o "system" -s "system"

  smith om -l "$LOCKFILE_PATH" >/tmp/bashly_om_env.sh
  chmod +x /tmp/bashly_om_env.sh
  source /tmp/bashly_om_env.sh

  eval $(smith om -l "$LOCKFILE_PATH")
  eval $(smith om -l "$LOCKFILE_PATH")

  smith bosh -l "$LOCKFILE_PATH" >/tmp/bashly_bosh_env.sh
  chmod +x /tmp/bashly_bosh_env.sh
  source /tmp/bashly_bosh_env.sh

  eval $(smith bosh -l "$LOCKFILE_PATH")
  eval $(smith bosh -l "$LOCKFILE_PATH")

  smith open --lockfile=$LOCKFILE_PATH

}

# :command.function
tpi_version_command() {
  # src/version_command.sh
  OM_VERSION=${args[tag]}

  cd ~/workspace/ops-manager
  git pull ~/workspace/ops-manager &>/dev/null
  git checkout $OM_VERSION &>/dev/null
  echo -e "\n**************************"
  tile_version=$(cat web/config/auto-versions.yml | yq .telemetry_tile.version)
  echo -e "Ops Manager:\t$OM_VERSION"
  echo -e "Telemetry:\tv$tile_version"
  echo -e "**************************\n"
  git switch - &>/dev/null
  cd ~/workspace/tile/aqueduct-courier/ci/bashly

}

# :command.function
tpi_tkgi_command() {
  # src/tkgi_command.sh
  sheepctl lock create --file "$PWD/config/tkgi-recipe.json" --lifetime 7d --description "tkgi-test-env-2-tpi" -u 'https://shepherd.run' -n tpi-telemetry-sdk-ci

}

# :command.function
tpi_renew_command() {
  # src/renew_command.sh
  if [[ ${args[foundation]:-} == "" ]]; then
  	export TMP_FOUNDATION_NAME=$1
  else
  	export TMP_FOUNDATION_NAME=${args[foundation]}
  fi

  tpi_get_command $TMP_FOUNDATION_NAME

  renew_foundation() {
  	$SHEPHERD_BINARY_PATH update lease "$ENV_IDENTIFIER" --namespace tpi-telemetry --expire-in 168h

  	echo -e "$TMP_FOUNDATION_NAME lease extended for 2 weeks"
  }

  renew_foundation

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        tpi_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v bosh >/dev/null 2>&1; then
    deps['bosh']="$(command -v bosh | head -n1)"
  else
    printf "missing dependency: bosh\n" >&2
    exit 1
  fi

  if command -v cf >/dev/null 2>&1; then
    deps['cf']="$(command -v cf | head -n1)"
  else
    printf "missing dependency: cf\n" >&2
    exit 1
  fi

  if command -v curl >/dev/null 2>&1; then
    deps['curl']="$(command -v curl | head -n1)"
  else
    printf "missing dependency: curl\n" >&2
    exit 1
  fi

  if command -v jq >/dev/null 2>&1; then
    deps['jq']="$(command -v jq | head -n1)"
  else
    printf "missing dependency: jq\n" >&2
    exit 1
  fi

  if command -v om >/dev/null 2>&1; then
    deps['om']="$(command -v om | head -n1)"
  else
    printf "missing dependency: om\n" >&2
    exit 1
  fi

  if command -v pivnet >/dev/null 2>&1; then
    deps['pivnet']="$(command -v pivnet | head -n1)"
  else
    printf "missing dependency: pivnet\n" >&2
    exit 1
  fi

  if command -v shepherd >/dev/null 2>&1; then
    deps['shepherd']="$(command -v shepherd | head -n1)"
  else
    printf "missing dependency: shepherd\n" >&2
    exit 1
  fi

  if command -v smith >/dev/null 2>&1; then
    deps['smith']="$(command -v smith | head -n1)"
  else
    printf "missing dependency: smith\n" >&2
    exit 1
  fi

  if command -v vault >/dev/null 2>&1; then
    deps['vault']="$(command -v vault | head -n1)"
  else
    printf "missing dependency: vault\n" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list)
      action="list"
      shift
      tpi_list_parse_requirements "$@"
      shift $#
      ;;

    create)
      action="create"
      shift
      tpi_create_parse_requirements "$@"
      shift $#
      ;;

    install)
      action="install"
      shift
      tpi_install_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      tpi_update_parse_requirements "$@"
      shift $#
      ;;

    print)
      action="print"
      shift
      tpi_print_parse_requirements "$@"
      shift $#
      ;;

    get)
      action="get"
      shift
      tpi_get_parse_requirements "$@"
      shift $#
      ;;

    open)
      action="open"
      shift
      tpi_open_parse_requirements "$@"
      shift $#
      ;;

    whoami)
      action="whoami"
      shift
      tpi_whoami_parse_requirements "$@"
      shift $#
      ;;

    maintain)
      action="maintain"
      shift
      tpi_maintain_parse_requirements "$@"
      shift $#
      ;;

    lease)
      action="lease"
      shift
      tpi_lease_parse_requirements "$@"
      shift $#
      ;;

    version)
      action="version"
      shift
      tpi_version_parse_requirements "$@"
      shift $#
      ;;

    tkgi)
      action="tkgi"
      shift
      tpi_tkgi_parse_requirements "$@"
      shift $#
      ;;

    renew)
      action="renew"
      shift
      tpi_renew_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      tpi_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
tpi_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        tpi_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --json)

        # :flag.case_no_arg
        args['--json']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
tpi_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        tpi_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['foundation']+x} ]]; then
          args['foundation']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['foundation']+x} ]]; then
    printf "missing required argument: FOUNDATION\nusage: tpi create FOUNDATION\n" >&2

    exit 1
  fi

  # :command.whitelist_filter
  if [[ -n ${args['foundation']:-} ]] && [[ ! ${args['foundation']:-} =~ ^(production-jammy|acceptance-jammy|staging-jammy)$ ]]; then
    printf "%s\n" "foundation must be one of: production-jammy, acceptance-jammy, staging-jammy" >&2
    exit 1
  fi

}

# :command.parse_requirements
tpi_install_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        tpi_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['foundation']+x} ]]; then
          args['foundation']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['foundation']+x} ]]; then
    printf "missing required argument: FOUNDATION\nusage: tpi install FOUNDATION\n" >&2

    exit 1
  fi

  # :command.whitelist_filter
  if [[ -n ${args['foundation']:-} ]] && [[ ! ${args['foundation']:-} =~ ^(production-jammy|acceptance-jammy)$ ]]; then
    printf "%s\n" "foundation must be one of: production-jammy, acceptance-jammy" >&2
    exit 1
  fi

}

# :command.parse_requirements
tpi_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        tpi_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['foundation']+x} ]]; then
          args['foundation']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['foundation']+x} ]]; then
    printf "missing required argument: FOUNDATION\nusage: tpi update FOUNDATION\n" >&2

    exit 1
  fi

  # :command.whitelist_filter
  if [[ -n ${args['foundation']:-} ]] && [[ ! ${args['foundation']:-} =~ ^(production-jammy|acceptance-jammy|staging-jammy)$ ]]; then
    printf "%s\n" "foundation must be one of: production-jammy, acceptance-jammy, staging-jammy" >&2
    exit 1
  fi

}

# :command.parse_requirements
tpi_print_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        tpi_print_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="print"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --collect)

        # :flag.case_no_arg
        args['--collect']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['foundation']+x} ]]; then
          args['foundation']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['foundation']+x} ]]; then
    printf "missing required argument: FOUNDATION\nusage: tpi print FOUNDATION [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.whitelist_filter
  if [[ -n ${args['foundation']:-} ]] && [[ ! ${args['foundation']:-} =~ ^(production-jammy|acceptance-jammy|staging-jammy|tas-6-test-env-1)$ ]]; then
    printf "%s\n" "foundation must be one of: production-jammy, acceptance-jammy, staging-jammy, tas-6-test-env-1" >&2
    exit 1
  fi

}

# :command.parse_requirements
tpi_get_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        tpi_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['foundation']+x} ]]; then
          args['foundation']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['foundation']+x} ]]; then
    printf "missing required argument: FOUNDATION\nusage: tpi get FOUNDATION\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
tpi_open_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        tpi_open_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="open"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['foundation']+x} ]]; then
          args['foundation']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['foundation']+x} ]]; then
    printf "missing required argument: FOUNDATION\nusage: tpi open FOUNDATION\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
tpi_whoami_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        tpi_whoami_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="whoami"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
tpi_maintain_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        tpi_maintain_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="maintain"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
tpi_lease_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        tpi_lease_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="lease"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['id']+x} ]]; then
    printf "missing required argument: ID\nusage: tpi lease ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
tpi_version_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        tpi_version_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="version"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['tag']+x} ]]; then
          args['tag']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['tag']+x} ]]; then
    printf "missing required argument: TAG\nusage: tpi version TAG\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
tpi_tkgi_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        tpi_tkgi_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tkgi"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
tpi_renew_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        tpi_renew_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="renew"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['foundation']+x} ]]; then
          args['foundation']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['foundation']+x} ]]; then
    printf "missing required argument: FOUNDATION\nusage: tpi renew FOUNDATION\n" >&2

    exit 1
  fi

  # :command.whitelist_filter
  if [[ -n ${args['foundation']:-} ]] && [[ ! ${args['foundation']:-} =~ ^(production-jammy|acceptance-jammy|staging-jammy)$ ]]; then
    printf "%s\n" "foundation must be one of: production-jammy, acceptance-jammy, staging-jammy" >&2
    exit 1
  fi

}

# :command.user_hooks
before_hook() {
  # src/before.sh
  PS4='+ ${BASH_SOURCE:-}:${FUNCNAME[0]:-}:L${LINENO:-}:   '

  set_shepherd_binary_path
  ensure_vault_login
  ensure_shepherd_login

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -euo pipefail

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"
  before_hook

  case "$action" in
    "list") tpi_list_command ;;
    "create") tpi_create_command ;;
    "install") tpi_install_command ;;
    "update") tpi_update_command ;;
    "print") tpi_print_command ;;
    "get") tpi_get_command ;;
    "open") tpi_open_command ;;
    "whoami") tpi_whoami_command ;;
    "maintain") tpi_maintain_command ;;
    "lease") tpi_lease_command ;;
    "version") tpi_version_command ;;
    "tkgi") tpi_tkgi_command ;;
    "renew") tpi_renew_command ;;
  esac
}

initialize
run "$@"
